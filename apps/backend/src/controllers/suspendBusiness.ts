import fs from 'fs';
import path, { dirname } from 'path';
import { fileURLToPath } from 'url';
import { pool } from '@min-two/postgres-node';

const ensureSqlExists = () => {
  if (fs.existsSync('../migrations/sql')) {
    return true;
  } else {
    return false;
  }
};

export type Suspend = { id: string; adminName: string };

function getMigrationFileName() {
  const timestamp = Date.now(); // Get current timestamp
  const uniqueIdentifier = Math.random().toString(20).substring(2, 7); // Generate a random unique identifier
  return `adminGen_suspend-business_stores.store_${timestamp}_${uniqueIdentifier}.sql`;
}

function getMigrationDeatils(id: string, adminName: string) {
  const migrationName = getMigrationFileName();
  const adminLine = `-- Auto-generated by Admin ${adminName}\n`;
  const migrationContent = `-- Migration ${'suspend-business'} action on table stores.store\n`;

  const migrationContentWithUpdate = `
  ${adminLine} ${migrationContent}
    UPDATE stores.store
    SET is_pending = true
    WHERE sid = '${id}';`;

  // Return migration content as a string
  return {
    sqlName: migrationName,
    sqlContents: migrationContentWithUpdate,
  };
}

function uploadMigration(contents: string, name: string) {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);

  const directory = path.join(__dirname, '..', '..', '..', 'migrations', 'sql');
  const where = path.join(directory, name);

  fs.writeFile(where, contents, (err) => {
    if (err) {
      console.error('Error with admin action', err);
    }
  });
  return where;
}

const updateMigrationTable = async (name: string) => {
  try {
    const client = await pool.connect();
    const query = 'INSERT INTO public.migration (name) VALUES ($1)';
    const values = [name];
    await client.query(query, values);
    client.release();
  } catch (error) {
    // Handle the error appropriately, you can log it or throw a custom error
    throw new Error('Error updating migration table');
  }
};

async function deleteFile(filePath: string) {
  try {
    await fs.promises.unlink(filePath);
    console.log(`File ${filePath} deleted successfully.`);
  } catch (err) {
    console.error(`Error deleting file ${filePath}:`, err);
  }
}

const runMigration = async (migration: string) => {
  try {
    const client = await pool.connect();

    await client.query(migration);
    client.release();
  } catch (error) {
    // Handle the error appropriately, you can log it or throw a custom error
    console.log(error);
    throw new Error('Error updating migration table');
  }
};

export const handleSuspendUser = async (suspendDetails: Suspend) => {
  const hasSqlDirectory = ensureSqlExists();
  if (hasSqlDirectory) {
    const deatils = getMigrationDeatils(
      suspendDetails.id,
      suspendDetails.adminName
    );
    //   location of file
    const where = uploadMigration(deatils.sqlContents, deatils.sqlName);
    try {
      await runMigration(deatils.sqlContents);
      await updateMigrationTable(deatils.sqlName);
    } catch (e) {
      deleteFile(where);
      throw new Error('Error with migration process');
    }
    console.log(where);
  } else {
    throw new Error('Sql directory does not exist');
  }
};
