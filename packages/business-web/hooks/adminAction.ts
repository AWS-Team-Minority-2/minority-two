import { useEffect, useState, useCallback } from 'react';
import * as FileSystem from 'expo-file-system';
import { Asset } from 'expo-asset';

// import { useQuery } from '@apollo/client';
// import { GET_STORES } from '../mutations/index';

/* Hook that handles admin actions **/

// TODO: move to iso if necessary

interface Store {
  city: string;
  cover_image: string;
  is_online: boolean;
  lat: string;
  long: string;
  name: string;
  render_type: 'featured' | 'restaurant' | 'service' | 'shop';
  state: string;
  zip_code: number;
  is_pending: boolean;
}

type TableName = 'stores.store';

type StoreId = string;

type Suspend = { id: StoreId; adminName: string };

interface MigrationActions {
  tableName: TableName;
  action: string;
  data: { id: StoreId; adminName: string };
}

function getNextMigrationFileName(actions: MigrationActions) {
  const timestamp = Date.now(); // Get current timestamp
  const uniqueIdentifier = Math.random().toString(20).substring(2, 7); // Generate a random unique identifier
  return `adminGen_${actions.action}_${actions.tableName}_${timestamp}_${uniqueIdentifier}.sql`;
}

function createMigration(actions: MigrationActions) {
  const migrationName = getNextMigrationFileName(actions);
  const adminLine = `-- Auto-generated by Admin ${actions.data.adminName}\n`;
  const migrationContent = `-- Migration ${actions.action} action on table ${actions.tableName}\n`;

  const migrationContentWithUpdate = `
  ${adminLine} ${migrationContent}
    UPDATE ${actions.tableName}
    SET is_pending = true
    WHERE id = '${actions.data.id}';`;

  // Return migration content as a string
  return {
    sqlName: migrationName,
    sqlContents: migrationContentWithUpdate,
  };
}

// // Create the migration file in the SQL directory
// const migrationPath = `./sql/${migrationName}`;
// fs.writeFileSync(migrationPath, migrationContent);

// // Execute the migration using your migration runner (assuming it's a shell command)
// const migrationCommand = `your_migration_runner_command --file ${migrationPath}`;
// exec(migrationCommand, (error, stdout, stderr) => {
//   if (error) {
//     console.error(`Error executing migration: ${error.message}`);
//     return;
//   }
//   if (stderr) {
//     console.error(`Migration stderr: ${stderr}`);
//     return;
//   }
//   console.log(`Migration stdout: ${stdout}`);
// });

export function adminActions() {
  const suspendBusiness = async (props: Suspend) => {
    const { id, adminName } = props;
    const migrationDirectory = './sql';

    // console.log(fs.existsSync(migrationDirectory));

    const migrationData = createMigration({
      action: 'suspend',
      tableName: 'stores.store',
      data: { id, adminName },
    });

    // const dirInfo = await FileSystem.getInfoAsync(
    //   '../../../apps/migrations/sql'
    // );

    // async function getCurrentDirectory() {
    //   try {
    //     const asset = Asset.fromModule(require('../../../apps/migrations/sql'));
    //     await asset.downloadAsync(); // Ensures the asset is downloaded (if it's remote)

    //     console.log('Current directory:', asset.localUri || asset.uri);
    //   } catch (error) {
    //     console.error('Error getting current directory:', error);
    //   }
    // }
    //
    // getCurrentDirectory();
  };

  return {
    suspend: suspendBusiness,
  };
}
